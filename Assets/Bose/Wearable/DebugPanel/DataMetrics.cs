using System.Collections.Generic;
using UnityEngine;

namespace Bose.Wearable
{
	/// <summary>
	/// Calculates various metrics about data transfer between a Wearable Device and the Unity plugin. Primarily used
	/// for debugging providers and bridges.
	/// </summary>
	public class DataMetrics : MonoBehaviour
	{
		/// <summary>
		/// The number of Unity frames that were rendered in the last second
		/// </summary>
		public float RenderFramesLastSecond
		{
			get { return _renderFramesLastSecond; }
		}

		private float _renderFramesLastSecond;

		/// <summary>
		/// The number of sensor frames received in the last second
		/// </summary>
		public float SensorFramesLastSecond
		{
			get { return _sensorFramesLastSecond; }
		}

		private float _sensorFramesLastSecond;

		/// <summary>
		/// The number of sensor frames generated by the provider the last time it was updated
		/// </summary>
		public int SensorFramesLastUpdate
		{
			get { return _lastTransferSize; }
		}
		
		private int _lastTransferSize;

		/// <summary>
		/// The time between the most recent sensor frame transfer and the prior transfer, in seconds, or null if
		/// no data has been received
		/// </summary>
		public float? LastTransferInterval
		{
			get { return _lastTransferInterval; }
		}

		private float? _lastTransferInterval;

		/// <summary>
		/// The age in seconds of the most recently-received data
		/// </summary>
		public float? LastTransferAge
		{
			get
			{
				if (_lastTransferInterval.HasValue)
				{
					return Time.unscaledTime - _lastTransferTime;
				}
				else
				{
					return null;
				}
			}
		}

		/// <summary>
		/// The most recent timestamp received from the provider, or null if no data has been received
		/// </summary>
		public float? LastTimestamp
		{
			get { return _lastTimestamp; }
		}

		private float? _lastTimestamp;

		/// <summary>
		/// The difference between the the last timestamp received by the device and Time.unscaledTime when it was
		/// received, or null of no data has been received
		/// </summary>
		public float? UnityToDeviceOffset
		{
			get { return _unityToDeviceOffset; }
		}

		/// <summary>
		/// The number of seconds over which to measure render and sensor frame rate; acts as a sliding window
		/// </summary>
		[SerializeField]
		private float _frameCountTimeSeconds;
		
		/// <summary>
		/// If true, assume that timestamps returned by the device are reliable, improving the accuracy of the
		/// SensorFramesPerSecond calculation. If this assumption cannot be made, set this to false to use only local
		/// time sources in rate calculations.
		/// </summary>
		[SerializeField]
		private bool _frameTimestampsAreReliable;

		private float? _unityToDeviceOffset;

		private WearableControl _wearableControl;
		
		private Queue<float> _renderFrameTimes;
		private Queue<float> _sensorFrameTimes;
		private float _lastTransferTime;

		private void Start()
		{
			_wearableControl = WearableControl.Instance;
			
			_renderFramesLastSecond = 0.0f;
			_lastTransferSize = 0;
			_lastTransferInterval = null;
			_lastTimestamp = null;
			_unityToDeviceOffset = null;
			
			_renderFrameTimes = new Queue<float>();
			_sensorFrameTimes = new Queue<float>();
			_lastTransferTime = 0.0f;
		}

		private void Update()
		{
			UpdateRenderStats();

			if (_wearableControl.UpdateMode == UnityUpdateMode.Update)
			{
				UpdateSensorStats();
			}
		}

		private void LateUpdate()
		{
			if (_wearableControl.UpdateMode == UnityUpdateMode.LateUpdate)
			{
				UpdateSensorStats();
			}
		}

		private void FixedUpdate()
		{
			if (_wearableControl.UpdateMode == UnityUpdateMode.FixedUpdate)
			{
				UpdateSensorStats();
			}
		}
		
		private void Reset()
		{
			_frameCountTimeSeconds = 1.0f;
			_frameTimestampsAreReliable = true;
		}

		private void OnValidate()
		{
			if (_frameCountTimeSeconds < 0.0f)
			{
				_frameCountTimeSeconds = 0.0f;
			}
		}

		/// <summary>
		/// Update data used in calculating RenderFramesLastSecond. Meant to be called from Update().
		/// </summary>
		private void UpdateRenderStats()
		{
			float currentTime = Time.unscaledTime;
			
			_renderFrameTimes.Enqueue(currentTime);
			while (_renderFrameTimes.Count > 0
			       && _renderFrameTimes.Peek() < currentTime - _frameCountTimeSeconds)
			{
				_renderFrameTimes.Dequeue();
			}

			_renderFramesLastSecond = (float) _renderFrameTimes.Count / _frameCountTimeSeconds;
		}
		
		/// <summary>
		/// Update data used in calculating SensorFramesLastSecond, SensorFramesLastUpdate, LastTransferInterval,
		/// LastTimestamp, and UnityToDeviceOffset. Meant to be called from the same update function that WearableControl uses.
		/// </summary>
		private void UpdateSensorStats()
		{
			float currentTime = Time.unscaledTime;
			
			// Transfer size
			_lastTransferSize = _wearableControl.CurrentSensorFrames.Count; 
			
			// Only update if a transfer occured this time
			if (_lastTransferSize > 0)
			{
				_lastTransferInterval = currentTime - _lastTransferTime;
				_lastTransferTime = currentTime;
				_lastTimestamp = _wearableControl.CurrentSensorFrames[_lastTransferSize - 1].timestamp;
				_unityToDeviceOffset = _lastTimestamp - currentTime;

				// Add new frames
				for (int i = 0; i < _lastTransferSize; i++)
				{
					if (_frameTimestampsAreReliable)
					{
						// Translate the frame timestamps to Unity-time by subtracting the offset
						_sensorFrameTimes.Enqueue(
							_wearableControl.CurrentSensorFrames[i].timestamp - _unityToDeviceOffset.Value);
					}
					else
					{
						// Use the receive time if device timestamps aren't reliable
						_sensorFrameTimes.Enqueue(currentTime);
					}
				}
			}
			
			// Remove old sensor frames
			while (_sensorFrameTimes.Count > 0
			       && _sensorFrameTimes.Peek() < currentTime - _frameCountTimeSeconds)
			{
				_sensorFrameTimes.Dequeue();
			}

			_sensorFramesLastSecond = _sensorFrameTimes.Count / _frameCountTimeSeconds;
		}
	}
}
